#
# SPDX-License-Identifier: GPL-2.0
#
# Copyright (c) 2018 Intel Corporation
#
# Authors: Liu Jingqi <jingqi.liu@intel.com>
#

#!/bin/bash

bc_scale="scale=2;"

# parameters update by calc_mem_parameter()
dram_req_size=0
aep_req_size=0

adjust_mem()
{
    local nodes=($1)
    local req_size=$2

    local req_free_size_per_node=$(echo "$bc_scale ($req_size/${#nodes[@]}) * 1024" | bc -l)
    echo "request free size $req_free_size_per_node MB on nodes ${nodes[@]}"
    for i in ${nodes[@]}; do

	# better to parse this from /sys/devices/system/node/node*/vmstat
	# comments by fengguang
	local free=$(numactl -H | grep -e "node $i free:" | awk '{print $4}')
	local to_hold_size=$(echo "scale=0; $free - $req_free_size_per_node" | bc)

	to_hold_size=${to_hold_size%.*}

		# Need reserve some memory, or the qemu process will be killed for not enough memory
		to_hold_size=$(($to_hold_size - 500))

	if [[ $to_hold_size -gt 0 ]]; then
	  echo "usemem will hold $to_hold_size MB on node $i"
		  usemem_cmd=(
			$usemem_bin
			--step 2m --prefault --mlock --sleep -1
			--detach "$to_hold_size"m
		  )
		  echo "numactl -m$i ${usemem_cmd[@]}"
		  numactl -m$i ${usemem_cmd[@]} &
	  #numactl -m$i $usemem_bin --step 2m --prefault --mlock --sleep -1 --detach "$to_hold_size"m &
	else
	    echo "skip usemem on node $i, no enough free size."
	    return -1
	fi
    done;

    wait

    return 0
}


calc_mem_parameter()
{
    local ratio_deno=$(echo "$bc_scale $wl_dram_ratio + $wl_aep_ratio" | bc -l);
    dram_req_size=$(echo "$bc_scale $wl_req_mem * ($wl_dram_ratio/$ratio_deno)" | bc -l);
    aep_req_size=$(echo "$bc_scale $wl_req_mem * ($wl_aep_ratio/$ratio_deno)" | bc -l)

    echo "dram nodes = ${dram_node[@]}"
    echo "aep nodes = ${aep_node[@]}"
    echo "workload request mem = $wl_req_mem GB (dram:aep = $wl_dram_ratio:$wl_aep_ratio)"
    echo "workload request dram = $dram_req_size GB"
    echo "workload request aep = $aep_req_size GB"

    return;
}

start_vm()
{
  $vm_script $vm_memory $interleave_nodes &
}

wait_for_vm_ready()
{
	while [[ true ]]; do
	ssh -p $ssh_port $vm_user@$vm_host -o ConnectTimeout=1 exit >/dev/null 2>&1
	if [[ $? -eq 0 ]]; then
		echo "ssh to host $vm_host is ready"
		return
	fi
		sleep 1
	done;
}

ssh_port=2287

run_work_load()
{
    local workload="$1"
    ssh -p $ssh_port $vm_user@$vm_host $workload
}

clean_up()
{
    kill $(pidof usemem)
    #kill $(pidof qemu-system-x86_64)
}

thp=never
setup_sys()
{
    echo $thp > /sys/kernel/mm/transparent_hugepage/enabled
    echo 0 > /proc/sys/kernel/numa_balancing
    lsmod | grep -q kvm_ept_idle || insmod /lib/modules/`uname -r`/kernel/arch/x86/kvm/kvm-ept-idle.ko
}

get_interleave_nodes()
{
	local j=0
	for i in ${dram_node[@]}; do
	if [ $j -gt 0 ]; then
		interleave_nodes+=",$i"
			else
		interleave_nodes+="$i"
	fi
			j=$(($j + 1))
	done
	for i in ${aep_node[@]}; do
	interleave_nodes+=",$i"
	done
	if [ -z "$interleave_nodes" ]; then
		interleave_nodes="0,1,2,3"
	fi
	echo "interleave_nodes=$interleave_nodes"
}

setup_log()
{
	log_dir=`pwd`/testlogs
	mkdir $log_dir

	log_file=$log_dir/$(basename $0)-$(date +'%Y%m%d_%H%M%S')
	log_file+="-$wl_block_size-$wl_threads"
	echo "log file: $log_file"
	exec > $log_file 2>&1
}

# args:
#	1: the ratio of dram and aep
#		1 -- 1:1
#		2 -- 1:2
#		3 -- 1:3
#		4 -- 1:4
#	2: the dram nodes, default is "dram=0,1"
#	3: the aep nodes, default is "aep=2,3"
echo "Example: $0 2 dram=0,1 aep=2,3"

# mean dram:aep
wl_dram_ratio=1
wl_aep_ratio=1

if [ -n "$1" ]; then
	wl_aep_ratio=$1
fi

# the operation of work load
wl_opt="read"

# Sysbench testing

# the block size of work load
wl_block_size=1

# the threads of work load
wl_threads=32

wl_total_size=$(($wl_block_size * $wl_threads * 2))

# work load size, unit is G here
wl_req_mem=$(($wl_block_size * $wl_threads))

# A little bigger than needed
wl_req_mem=$(($wl_req_mem + 2))

# node id with dram
dram_node=(0 1)
if [ -n "$2" ]; then
	dram_node=$(echo $2 |awk -F'=' '{print $2}'|awk 'gsub(/,/," "){print $0}')
	echo "DRAM nodes include $dram_node"
	dram_node=($dram_node)
fi

# node id with aep
aep_node=(2 3)
if [ -n "$3" ]; then
	aep_node=$(echo $3 |awk -F'=' '{print $2}'|awk 'gsub(/,/," "){print $0}')
	echo "AEP nodes include $aep_node"
	aep_node=($aep_node)
fi

setup_log
setup_sys
get_interleave_nodes

# change your user host here
vm_user="root"
vm_host="localhost"

# set your usemem binary path here
usemem_bin="/home/jingqi/workspace/vm-scalability/usemem"

calc_mem_parameter

pid_usemem="$(pidof usemem)"
if [ -z "$pid_usemem" ]; then
	adjust_mem "${dram_node[*]}" $dram_req_size
	if  [[ $? -ne 0 ]]; then
	echo "test not run because errors happened"
	clean_up
	exit -1
	fi
fi

# Start VM
vm_memory=$wl_req_mem
vm_memory+='G'
echo "the memory of VM is $vm_memory"

vm_script="/home/jingqi/vm-script/sysbench-vm.sh"
pid_qemu=$(pidof qemu-system-x86_64)
if [ -z "$pid_qemu" ]; then
	start_vm
fi

wait_for_vm_ready

wl_total_size+="G"
wl_block_size+="G"

wl_opt="read"
run_work_load "~/workload.sh $wl_opt $wl_block_size $wl_total_size $wl_threads"


wl_opt="write"
run_work_load "~/workload.sh $wl_opt $wl_block_size $wl_total_size $wl_threads"

#run_work_load "~/workload.sh read 8G 16G 1"
#run_work_load "~/workload.sh write 8G 16G 1"
#clean_up

